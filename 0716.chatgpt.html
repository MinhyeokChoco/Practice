<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 콜백
    // function fetchData(callback) {
    //     setTimeout(() => {
    //         const data = "some data";
    //         callback(data);
    //     }, 1000);
    // }

    // fetchData((data) => {
    //     console.log("Callback:", data);
    // });

    // --------------------------------------

    // 콜백 결과 값 확인

    // function fetchData(callback) {
    //     setTimeout(() => {
    //         const data = "some data";
    //         callback(data);
    //     }, 1000);
    // }

    // const result = fetchData((data) => {
    //     console.log("Callback:", data);
    // });

    // console.log("Return value:", result); // 이 줄이 실행되면 result는 undefined 입니다.

    // ------------------------------------------------------------------------------

    // 리턴값 프라미스

    // function fetchData() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             const data = "some data";
    //             resolve(data);
    //         }, 1000);
    //     });
    // }

    // const result = fetchData();
    // console.log("Return value:", result); // 이 줄이 실행되면 result는 Promise 입니다.

    // result.then((data) => {
    //     console.log("Promise:", data);
    // }).catch((error) => {
    //     console.error("Error:", error);
    // });

    // ------------------------------------------

    // 프라미스
    // function fetchData() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             const data = "some data";
    //             resolve(data);
    //         }, 5000);
    //     });
    // }

    // fetchData().then(console.log("Promise"))

    // 안되는 이유 :
    // 여기서 console.log("Promise")는 함수 호출을 의미합니다.
    // 즉, fetchData()가 실행되고 나서 즉시 console.log("Promise")가 실행됩니다.
    // 그리고 .then() 메서드에는 함수가 아닌 결과 값이 전달됩니다. 따라서 fetchData가 끝나기도 전에 "Promise"가 출력되고 있습니다.

    // 해결 방법 :
    // .then() 메서드에 전달하는 것은 콜백 함수여야 합니다.
    // 따라서 console.log("Promise") 대신에 함수를 넘겨주어야 합니다.

    // fetchData().then((data) => {
    //     console.log("Promise : ", data);
    // })
    //     .catch((error) => {
    //         console.error("Error:", error);
    //     });

    // ------------------------------------------------------

    // Async / Await
    // async function fetchData() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             const data = "some data";
    //             resolve(data);
    //         }, 1000);
    //     });
    // }

    // async function main() {
    //     try {
    //         const data = await fetchData();
    //         console.log("Async/Await:", data);
    //     } catch (error) {
    //         console.error("Error:", error);
    //     }
    // }

    // main();

    // --------------------------------------------

    // // 비동기 작업을 프라미스로 처리
    // function fetchData() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             const data = "some data";
    //             resolve(data);
    //         }, 1000);
    //     });
    // }

    // // 프라미스 사용
    // fetchData()
    //     .then((data) => {
    //         console.log("Promise:", data);
    //     })
    //     .catch((error) => {
    //         console.error("Error:", error);
    //     });

    // ----------------------------------------------------

    // // 비동기 작업을 프라미스로 처리
    // function fetchData() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             const data = "some data";
    //             resolve(data);
    //         }, 1000);
    //     });
    // }

    // // async/await를 사용하여 동기적인 코드 작성
    // async function main() {
    //     try {
    //         const data = await fetchData();
    //         console.log("Async/Await:", data);
    //     } catch (error) {
    //         console.error("Error:", error);
    //     }
    // }

    // main();
</script>

</html>